<?php

define('COMMERCE_SUBSCRIPTION_CREATED',         1);
define('COMMERCE_SUBSCRIPTION_TRIAL',           2);
define('COMMERCE_SUBSCRIPTION_ACTIVE',          3);
define('COMMERCE_SUBSCRIPTION_FINISHED',        4);
define('COMMERCE_SUBSCRIPTION_CANCELLED_USER',  5);
define('COMMERCE_SUBSCRIPTION_CANCELLED_ADMIN', 6);
define('COMMERCE_SUBSCRIPTION_FAILED',          7);

define('COMMERCE_SUBSCRIPTION_DURATION_DAYS',   1);
define('COMMERCE_SUBSCRIPTION_DURATION_WEEKS',  2);
define('COMMERCE_SUBSCRIPTION_DURATION_MONTHS', 3);
define('COMMERCE_SUBSCRIPTION_DURATION_YEARS',  4);

/**
 * Implementation of hook_commerce_product_type_info()
 */

function commerce_subscription_commerce_product_type_info() {

  return array(
    'subscription' => array(
      'type' => 'subscription',
      'name' => 'Subscription',
      'description' => 'A subscription product type',
      'help' => '',
    ),
  );
}

/**
 * Implementation of hook_entity_info()
 */

function commerce_subscription_entity_info() {

  $entity_info = array();

  $entity_info['commerce_subscription'] = array(
    'label' => t('Subscription'),
    'controller class' => 'CommerceSubscriptionEntityController',
    'base table' => 'commerce_subscription',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'subscription_id',
      'label' => 'title',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'uri callback' => 'commerce_subscription_uri',
    'bundles' => array(
      'membership' => array(
        'label' => 'Membership',
      ),
      /* Could extend this with subscription types like product entity? */
    ),
    'load hook' => 'commerce_subscription_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Admin display'),
        'custom settings' => FALSE,
      ),
    ),
  );

  $entity_info['commerce_subscription_recurrance'] = array(
    'label' => t('Subscription'),
    'controller class' => 'CommerceSubscriptionRecurranceEntityController',
    'base table' => 'commerce_subscription_recurrance',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'subscription_recurrance_id',
      'label' => 'title',
      // 'bundle' => 'type',
    ),
    /*
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    */
    'uri callback' => 'commerce_subscription_uri',
    /*
    'bundles' => array(
      'membership' => array(
        'label' => 'Membership',
      ),
      # Could extend this with subscription types like product entity?
    ),
    */
    'load hook' => 'commerce_subscription_recurrance_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Admin display'),
        'custom settings' => FALSE,
      ),
    ),
  );

  return $entity_info;
}

/**
 * Implements hook_enable().
 * commerce_product will have created our subscription bundle. We'll add a few more fields that we require here.
 */
function commerce_subscription_enable() {

  // Create the fields first:
  commerce_subscription_set_up_fields();

  // Then create field instances:
  commerce_subscription_set_up_field_instances();
}

/*
 * Implementation of hook_entity_property_info()
 */

function commerce_subscription_entity_property_info() {

  $info = array();

  // Add meta-data about the commerce_product this module defines.
  $subscription_product_properties = &$info['commerce_product']['properties'];

  $subscription_product_properties['subscription_role'] = array(
    'label' => t('Subscription role'),
    'type' => 'integer',
    'description' => t('Subscription role'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_period'] = array(
    'label' => t('Subscription period'),
    'type' => 'integer',
    'description' => t('Subscription period'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_units'] = array(
    'label' => t('Subscription period units'),
    'type' => 'integer',
    'description' => t('Subscription period units'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_trial_1_period'] = array(
    'label' => t('Subscription trial period'),
    'type' => 'integer',
    'description' => t('Subscription trial period'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_trial_1_units'] = array(
    'label' => t('Subscription trial period units'),
    'type' => 'integer',
    'description' => t('Subscription trial period units'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_trial_2_period'] = array(
    'label' => t('Subscription second trial period'),
    'type' => 'integer',
    'description' => t('Subscription second trial period'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_trial_2_units'] = array(
    'label' => t('Subscription second trial period units'),
    'type' => 'integer',
    'description' => t('Subscription second trial period units'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_recurs'] = array(
    'label' => t('Subscription recurs'),
    'type' => 'list_boolean',
    'description' => t('Subscription recurs'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  $subscription_product_properties['subscription_recur_limit'] = array(
    'label' => t('Subscription recur limit'),
    'type' => 'integer',
    'description' => t('Subscription recur limit'),
    'getter callback' => 'commerce_subscription_product_get_property',
    'setter callback' => 'commerce_subscription_product_set_property',
  );

  // Add meta-data about the subscription entity this module defines.
  $subscription_entity_properties = &$info['commerce_subscription']['properties'];

  $subscription_entity_properties['status'] = array(
    'label' => t('Status'),
    'type' => 'integer',
    'description' => t('The current status of this subscription. Created, Active, Cancelled, Etc.'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  $subscription_entity_properties['role'] = array(
    'label' => t('Role'),
    'type' => 'integer',
    'description' => t('The role this subscription grants'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  $subscription_entity_properties['product'] = array(
    'label' => t('Product ID'),
    'type' => 'integer',
    'description' => t('The ID of the product bought to grant this subscription'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  $subscription_entity_properties['uid'] = array(
    'label' => t('User ID'),
    'type' => 'integer',
    'description' => t('The user that has this subscription'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  $subscription_entity_properties['changed'] = array(
    'label' => t('Changed'),
    'type' => 'integer',
    'description' => t('When the subscription was last changed'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  // Add meta-data about the subscription_recurrance entity
  $subscription_recurrance_properties = &$info['commerce_subscription_recurrance']['properties'];

  $subscription_recurrance_properties['transaction'] = array(
    'label' => t('Transaction ID'),
    'type' => 'integer',
    'description' => t('Transaction ID for the payment that triggered the recurrance.'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  $subscription_recurrance_properties['subscription'] = array(
    'label' => t('Subscription ID'),
    'type' => 'integer',
    'description' => t('Subscription ID for the subscription that owns this recurrance.'),
    'getter callback' => 'commerce_subscription_entity_get_property',
    'setter callback' => 'commerce_subscription_entity_set_property',
  );

  return $info;
}

/**
 * Implementation of hook_disable()
 */

function commerce_subscription_disable() {

  // Get our field instance definitions:
  $field_instances_info = commerce_subscription_get_default_field_instances();

  $field_instances = array();

  // Then get the instances for each one
  foreach ($field_instances_info as $field_instance_info) {
    $field_instances[] = field_info_instance($field_instance_info['entity_type'], $field_instance_info['field_name'], $field_instance_info['bundle']);
  }

  // Add in the fields we made with commerce_price_create_instance();
  $field_instances[] = field_info_instance('commerce_product', 'subscription_trial_price', 'subscription');
  $field_instances[] = field_info_instance('commerce_product', 'subscription_trial_2_price', 'subscription');

  // Delete each instance
  foreach ($field_instances as $field_instance) {
    if ($field_instance) {
      field_delete_instance($field_instance, TRUE);
    }
  }

  // Get our field definitions:
  $fields = commerce_subscription_get_default_fields();

  // Add in the fields we made with commerce_price_create_instance();
  $fields[] = array('field_name' => 'subscription_trial_price');
  $fields[] = array('field_name' => 'subscription_trial_2_price');

  // Delete the fields
  foreach ($fields as $field) {
    if (field_info_field($field['field_name'])) {
      field_delete_field($field['field_name']);
    }
  }
}

/**
 * Callback for getting product properties.
 * @see commerce_subscription_entity_property_info()
 */
function commerce_subscription_product_get_property($subscription, array $options, $name) {

  switch ($name) {
    case 'subscription_role':
      return isset($subscription->subscription_role[LANGUAGE_NONE][0]['rid']) ? $subscription->subscription_role[LANGUAGE_NONE][0]['rid'] : NULL;
    case 'subscription_period':
    case 'subscription_units':
    case 'subscription_recurs':
    case 'subscription_recur_limit':
      $property = &$subscription->$name;
      return isset($property[LANGUAGE_NONE][0]['value']) ? $property[LANGUAGE_NONE][0]['value'] : NULL;
    case 'subscription_trial_1_period':
      $property = &$subscription->subscription_trial_period;
      return isset($property[LANGUAGE_NONE][0]['value']) ? $property[LANGUAGE_NONE][0]['value'] : NULL;
    case 'subscription_trial_1_units':
      $property = &$subscription->subscription_trial_units;
      return isset($property[LANGUAGE_NONE][0]['value']) ? $property[LANGUAGE_NONE][0]['value'] : NULL;
    case 'subscription_trial_2_period':
      $property = &$subscription->subscription_trial_period;
      return isset($property[LANGUAGE_NONE][1]['value']) ? $property[LANGUAGE_NONE][1]['value'] : NULL;
    case 'subscription_trial_2_units':
      $property = &$subscription->subscription_trial_units;
      return isset($property[LANGUAGE_NONE][1]['value']) ? $property[LANGUAGE_NONE][1]['value'] : NULL;
    default:
      return isset($subscription->$name) ? $subscription->$name : NULL;
  }
}

/**
 * Callback for setting product properties.
 * @see commerce_subscription_entity_property_info()
 */
function commerce_subscription_product_set_property($subscription, $name, $value) {

  switch ($name) {
    case 'subscription_role':
      $subscription->subscription_role[LANGUAGE_NONE][0]['rid'] = $value;
      break;
    case 'subscription_period':
    case 'subscription_units':
    case 'subscription_recurs':
    case 'subscription_recur_limit':
      $property = &$subscription->$name;
      $property[LANGUAGE_NONE][0]['value'] = $value;
      break;
    case 'subscription_trial_1_period':
      $property = &$subscription->subscription_trial_period;
      $property[LANGUAGE_NONE][0]['value'] = $value;
      break;
    case 'subscription_trial_1_units':
      $property = &$subscription->subscription_trial_units;
      $property[LANGUAGE_NONE][0]['value'] = $value;
      break;
    case 'subscription_trial_2_period':
      $property = &$subscription->subscription_trial_period;
      $property[LANGUAGE_NONE][1]['value'] = $value;
      break;
    case 'subscription_trial_2_units':
      $property = &$subscription->subscription_trial_units;
      $property[LANGUAGE_NONE][1]['value'] = $value;
      break;
    default:
      $subscription->$name = $value;
      break;
  }
}

/**
 * Loads all the subscriptions for a user
 */
function commerce_subscription_load_by_user($uid) {
  $subscriptions = commerce_subscription_load_multiple(array(), array('uid' => $uid));
  return $subscriptions ? $subscriptions : FALSE;
}

/**
 * Loads a subscription by ID
 */
function commerce_subscription_load($id) {
  $subscriptions = commerce_subscription_load_multiple(array(), array('subscription_id' => $id));
  return $subscriptions ? reset($subscriptions) : FALSE;
}

/**
 * Loads a subscription by ID
 */
function commerce_subscription_recurrance_load($id) {
  $recurrances = commerce_subscription_recurrance_load_multiple(array(), array('subscription_recurrance_id' => $id));
  return $recurrances ? reset($recurrances) : FALSE;
}

/**
 * Loads multiple subscriptions by ID or based on a set of matching conditions.
 *
 * @see entity_load()
 *
 * @param $subscription_ids
 *   An array of product IDs.
 * @param $conditions
 *   An array of conditions on the {commerce_subscription} table in the form
 *     'field' => $value.
 * @param $reset
 *   Whether to reset the internal product loading cache.
 *
 * @return
 *   An array of product objects indexed by product_id.
 */
function commerce_subscription_load_multiple($subscription_ids = array(), $conditions = array(), $reset = FALSE) {
  if (empty($subscription_ids) && empty($conditions)) {
    return array();
  }

  return entity_load('commerce_subscription', $subscription_ids, $conditions, $reset);
}

function commerce_subscription_recurrance_load_multiple($recurrance_ids = array(), $conditions = array(), $reset = FALSE) {
  if (empty($recurrance_ids) && empty($conditions)) {
    return array();
  }

  return entity_load('commerce_subscription_recurrance', $recurrance_ids, $conditions, $reset);
}

/**
 * Saves a subscription.
 *
 * @param $subscription
 *   The full subscription object to save.
 *
 * @return
 *   The saved subscription object.
 */
function commerce_subscription_save($subscription) {
  return entity_get_controller('commerce_subscription')->save($subscription);
}

/**
 * Saves a subscription recurrance.
 *
 * @param $subscription
 *   The full subscription object to save.
 *
 * @return
 *   The saved subscription object.
 */
function commerce_subscription_recurrance_save($recurrance) {
  return entity_get_controller('commerce_subscription_recurrance')->save($recurrance);
}

/**
 * Returns an initialized subscription object.
 *
 * @return
 *   A subscription object with all default fields initialized.
 */
function commerce_subscription_new($type = 'subscription') {
  return entity_get_controller('commerce_subscription')->create($type);
}

/**
 * Returns an initialized subscription recurrance object.
 *
 * @return
 *   A subscription object with all default fields initialized.
 */
function commerce_subscription_recurrance_new() {
  return entity_get_controller('commerce_subscription_recurrance')->create();
}

/**
 * Implements hook_views_api().
 */
function commerce_subscription_views_api() {
  return array(
    'api' => 2, // @todo - Shouldn't this be 3?
    'path' => drupal_get_path('module', 'commerce_subscription') . '/includes/views',
  );
}

function commerce_subscription_uri($subscription) {
  return array(
    'path' => 'subscription/' . $subscription->subscription_id,
  );
}

/**
 * Another @todo....
 * @param $subscription_id
 */

function commerce_subscription_view($subscription_id) {

  $weight = 0;

  $subscription = commerce_subscription_load($subscription_id);
  $subscriptions = array($subscription);

  field_attach_prepare_view('subscription', $subscriptions, 'full');
  entity_prepare_view('subscription', $subscriptions);
  $build = array();
  foreach ($subscriptions as $subscription) {
    $build['subscriptions'][$node->nid] = node_view($node, $view_mode, $langcode);
    $build['subscriptions'][$node->nid]['#weight'] = $weight;
    $weight++;
  }
  $build['nodes']['#sorted'] = TRUE;
  return $build;
}

function commerce_subscription_set_up_fields() {

  $fields = commerce_subscription_get_default_fields();

  foreach ($fields as $field) {

    // Check if this field exists already.
    if (!field_info_field($field['field_name'])) {

      // If not, create it.
      field_create_field($field);
    }
  }
}

function commerce_subscription_get_default_fields() {

  $fields[] = array(
    'field_name' => 'subscription_role',
    'type' => 'rolereference',
    'settings' => array(
      'referenceable_roles' => user_roles(),
    ),
  );

  $fields[] = array(
    'field_name' => 'subscription_period',
    'type' => 'number_integer',
  );

  $fields[] = array(
    'field_name' => 'subscription_units',
    'type' => 'number_integer',
  );

  $fields[] = array(
    'field_name' => 'subscription_trial_period',
    'type' => 'number_integer',
    'cardinality' => 2,
  );

  $fields[] = array(
    'field_name' => 'subscription_trial_units',
    'type' => 'number_integer',
    'cardinality' => 2,
  );

  $fields[] = array(
    'field_name' => 'subscription_recurs',
    'type' => 'list_boolean',
  );

  $fields[] = array(
    'field_name' => 'subscription_recur_limit',
    'type' => 'number_integer',
  );

  /*
  $fields[] = array(
    'field_name' => 'subscription_start_time',
    'type' => 'datetime',
  );

  $fields[] = array(
    'field_name' => 'subscription_end_time',
    'type' => 'datetime',
  );

  $fields[] = array(
    'field_name' => 'subscription_trial_end_time',
    'type' => 'datetime',
  );
  */

  $fields[] = array(
    'field_name' => 'subscription_product',
    'type' => 'commerce_product_reference',
    'locked' => TRUE,
  );

  return $fields;
}

function commerce_subscription_set_up_field_instances() {

  $instances = commerce_subscription_get_default_field_instances();

  // Set up any instances that don't already exist.
  foreach ($instances as $instance) {
    if (!field_info_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
      field_create_instance($instance);
    }
  }

  // Product module contains a handy function for adding a price field instance, so we'll use it to add our trial period prices

  // Cost of trial period 1:
  commerce_price_create_instance('subscription_trial_price', 'commerce_product', 'subscription', t('Trial period price'), 0, 'calculated_sell_price');

  // Cost of trial period 2:
  commerce_price_create_instance('subscription_trial_2_price', 'commerce_product', 'subscription', t('Trial period 2 price'), 0, 'calculated_sell_price');
}

function commerce_subscription_get_default_field_instances() {

  // Instances for subscription product:
  $instances[] = array(
    'field_name' => 'subscription_role',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Role'),
    'description' => 'The role that buying this subscription will give the user who purchased it.',
    'required' => TRUE,
  );

  $instances[] = array(
    'field_name' => 'subscription_period',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Period'),
    'description' => 'The length of time that a single period of this subscription runs for, in the units chosen by the field below.',
    'required' => TRUE,
  );

  $instances[] = array(
    'field_name' => 'subscription_units',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Period units'),
    'description' => 'The units the subscription period is expressed in. 1=Days, 2=Weeks, 3=Months, 4=Years',
    'required' => TRUE,
    /* @todo - Nice options. Below code doesn't work.
    'widget' => array(
      'type' => 'options_select',
      'options' => array(
        COMMERCE_SUBSCRIPTION_DURATION_DAYS   => 'Days',
        COMMERCE_SUBSCRIPTION_DURATION_WEEKS  => 'Weeks',
        COMMERCE_SUBSCRIPTION_DURATION_MONTHS => 'Months',
        COMMERCE_SUBSCRIPTION_DURATION_YEARS  => 'Years',
      ),
    ),
    */
  );

  $instances[] = array(
    'field_name' => 'subscription_trial_period',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Trial Period'),
    'description' => 'If the subscription should have a trial period, enter the length in here. Units are as per "Trial period units".',
    'required' => TRUE,
  );

  $instances[] = array(
    'field_name' => 'subscription_trial_units',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Trial period units'),
    'description' => 'The units the subscription trial period is expressed in. 1=Days, 2=Weeks, 3=Months, 4=Years',
    'required' => TRUE,
    /* @todo - Nice options. Below code doesn't work.
    'widget' => array(
      'type' => 'options_select',
      'options' => array(
        COMMERCE_SUBSCRIPTION_DURATION_DAYS   => 'Days',
        COMMERCE_SUBSCRIPTION_DURATION_WEEKS  => 'Weeks',
        COMMERCE_SUBSCRIPTION_DURATION_MONTHS => 'Months',
        COMMERCE_SUBSCRIPTION_DURATION_YEARS  => 'Years',
      ),
    ),
    */
  );

  $instances[] = array(
    'field_name' => 'subscription_recurs',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Subscription recurs'),
    'description' => 'This subscription recurs.',
    'required' => FALSE,
    'widget' => array(
      'type' => 'options_onoff',
    ),
  );

  $instances[] = array(
    'field_name' => 'subscription_recur_limit',
    'entity_type' => 'commerce_product',
    'bundle' => 'subscription',
    'label' => t('Subscription recur limit'),
    'description' => 'If the subscription should recur a limited number of times, enter the number here. To recur an unlimited number of times, enter zero here.',
    'required' => TRUE,
  );

  // Instances for membership bundle of subscription entity:
  // @todo - Is is worth abstracting membership out into a module that
  // builds on subscriptions?
  $instances[] = array(
    'field_name' => 'subscription_role',
    'entity_type' => 'commerce_subscription',
    'bundle' => 'membership',
    'label' => t('Role'),
    'description' => 'The role that buying this subscription gave the user who purchased it.',
    'required' => TRUE,
  );

  $instances[] = array(
    'field_name' => 'subscription_product',
    'entity_type' => 'commerce_subscription',
    'bundle' => 'membership',
    'label' => t('Product'),
    'description' => 'The product that was bought to create the membership.',
    'required' => TRUE,
  );

  // Instances for subscription_recurrance
  /*
  $instances[] = array(
    'field_name' => 'subscription_start_time',
    'entity_type' => 'commerce_subscription_recurrance',
    'bundle' => 'commerce_subscription_recurrance',
    'label' => t('Start Time'),
    'description' => 'The time the subscription starts.',
    'required' => TRUE,
  );

  $instances[] = array(
    'field_name' => 'subscription_end_time',
    'entity_type' => 'commerce_subscription_recurrance',

    'bundle' => 'commerce_subscription_recurrance',
    'label' => t('End Time'),
    'description' => 'The time the subscription ends.',
    'required' => TRUE,
  );
  */
  return $instances;
}

/*
 * @todo - Finish this. I'm not sure what state it's in....
 */
function commerce_subscription_menu() {

  $items['admin/subscription/%commerce_subscription'] = array(
    'title' => 'Edit subscription',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_subscription_edit', 2),
    'access arguments' => array('administer subscriptions'),
    'weight' => 0,
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * The start of an edit form for subscription entities
 * @todo - Finish this.
 *
 * @param $form
 * @param $form_state
 * @param $subscription
 */

function commerce_subscription_edit($form, $form_state, $subscription) {

  /*
   * @todo - Add form elements for:
   *
   *   uid - User reference? (http://drupal.org/project/references)
   *   status - Integer field?
   *
   *   Can probably take inspiration from node_form() for this.
   *   Then add validate & save & gubbins like that.
   */

  field_attach_form('commerce_subscription', $subscription, $form, $form_state);

  return $form;
}

/**
 * Translates subscription values to strings for display
 */

function commerce_subscription_statuses() {
  return array(
    COMMERCE_SUBSCRIPTION_CREATED         => 'Created',
    COMMERCE_SUBSCRIPTION_TRIAL           => 'Trial ',
    COMMERCE_SUBSCRIPTION_ACTIVE          => 'Active',
    COMMERCE_SUBSCRIPTION_FINISHED        => 'Finished',
    COMMERCE_SUBSCRIPTION_CANCELLED_USER  => 'Cancelled by user',
    COMMERCE_SUBSCRIPTION_CANCELLED_ADMIN => 'Cancelled by admin',
    COMMERCE_SUBSCRIPTION_FAILED          => 'Failed',
  );
}

/**
 * Getter function for commerce_subscription_entity_property_info()
 * @param $subscription
 * @param $options
 * @param $name
 */

function commerce_subscription_entity_get_property($subscription, array $options, $name) {

  switch ($name) {
    case 'role':
      return $subscription->subscription_role[LANGUAGE_NONE][0]['rid'];
    case 'product':
      return $subscription->subscription_product[LANGUAGE_NONE][0]['product_id'];
    default:
      return $subscription->$name;
  }
}

/**
 * Setter function for commerce_subscription_entity_property_info()
 * @param $subscription
 * @param $name
 * @param $value
 */

function commerce_subscription_entity_set_property($subscription, $name, $value) {

  switch ($name) {
    case 'role':
      $subscription->subscription_role[LANGUAGE_NONE][0]['rid'] = $value;
      break;
    case 'product':
      $subscription->subscription_product[LANGUAGE_NONE][0]['product_id'] = $value;
      break;
    default:
      $subscription->$name = $value;
      break;
  }
}

/**
 * Getter function for commerce_subscription_entity_property_info()
 * @param $subscription
 * @param $options
 * @param $name
 */

function commerce_subscription_recurrance_entity_get_property($subscription, array $options, $name) {

  switch ($name) {
    case 'start_time':
      return $subscription->subscription_start_time[LANGUAGE_NONE][0]['value'];
    case 'end_time':
      return $subscription->subscription_end_time[LANGUAGE_NONE][0]['value'];
    default:
      return $subscription->$name;
  }
}

/**
 * Setter function for commerce_subscription_entity_property_info()
 * @param $subscription
 * @param $name
 * @param $value
 */

function commerce_subscription_recurrance_entity_set_property($subscription, $name, $value) {

  switch ($name) {
    case 'start_time':
      $subscription->subscription_start_time[LANGUAGE_NONE][0]['value'] = $value;
      break;
    case 'end_time':
      $subscription->subscription_end_time[LANGUAGE_NONE][0]['value'] = $value;
      break;
    default:
      $subscription->$name = $value;
      break;
  }
}

/**
 * Grants a role to a user.
 * @param $uid User ID
 * @param $rid Role ID
 * @param $grant True to grant. False to remove.
 */

function commerce_subscription_grant_role($uid, $rid, $grant = TRUE) {
	
  // Get current user roles:
  $account = user_load($uid);
  $edit = array(
    'roles' => $account->roles,
  );

  // Load the role we want to grant
  $role = user_role_load($rid);

  // Add / Remove the role as appropriate.
  if ($grant) {
    $edit['roles'][$role->rid] = $role->name;
  }
  else {
    unset($edit['roles'][$role->rid]);
  }
  // Save it.
  user_save($account, $edit);

  return TRUE;
}

/**
 * Creates a subscription entity for a given product and user.
 * Use this to kick off a new subscription.
 *
 * @param $commerce_product A Subscription product
 * @param $uid User ID of the subscription owner
 */

function commerce_subscription_create_subscription($commerce_product, $uid) {

  // Create a new subscription:
  // @todo - Hardcoded to membership at the moment.
  // This could read from the product later on.
  $subscription = commerce_subscription_new('membership');

  // Get wrappers:
  $product_wrapper = entity_metadata_wrapper('commerce_product', $commerce_product);
  $subscription_wrapper = entity_metadata_wrapper('commerce_subscription', $subscription);

  // Copy the role.
  $subscription_wrapper->role->set($product_wrapper->subscription_role->value());

  // Set the user.
  $subscription_wrapper->uid->set($uid);

  // Set the product ID:
  $subscription_wrapper->product->set($product_wrapper->product_id->value());

  commerce_subscription_save($subscription);

  return $subscription;
}

/**
 * React to the IPN from PayPal
 * @param $ipn
 */

function commerce_subscription_commerce_paypal_ipn_process($order, $payment_method, $ipn) {

  $logs = "Order: <pre>" . print_r($order, true) . "</pre>";
  $logs .= "Payment Method: <pre>" . print_r($payment_method, true) . "</pre>";
  $logs .= "IPN: <pre>" . print_r($ipn, true) . "</pre>";
  watchdog("commerce_subscription IPN Process", $logs);
	
  //No need to load the IPN from transaction any more - it's passed in.
  $subscription_id = $ipn['custom'];

  switch ($ipn['txn_type']) {
    case 'subscr_signup': // subscription sign-up.
      commerce_subscription_update_subscription_status($subscription_id, COMMERCE_SUBSCRIPTION_ACTIVE);
      break;
    case 'subscr_cancel': // subscription cancellation:
      commerce_subscription_update_subscription_status($subscription_id, COMMERCE_SUBSCRIPTION_CANCELLED_USER);
      break;
    case 'subscr_failed': // subscription payment failure.
      commerce_subscription_update_subscription_status($subscription_id, COMMERCE_SUBSCRIPTION_FAILED);
      break;
    case 'subscr_payment': // subscription payment.

      // Save a new recurrence:
      $recurrence = commerce_subscription_recurrance_new();
      $recurrence_wrapper = entity_metadata_wrapper('commerce_subscription_recurrence', $recurrence);

      $recurrence->subscription->value($subscription_id);
      $recurrence->transaction->value($payment_method['instance_id']);

      commerce_subscription_recurrance_save($recurrence);

      break;
    case 'subscr_eot': // subscription's end-of-term.
      commerce_subscription_update_subscription_status($subscription_id, COMMERCE_SUBSCRIPTION_FINISHED);
      break;
    case 'subscr_modify': // subscription modification.
      // Denied! Someone else may wish to implement this.
      break;
    case 'cart': // Payment is not a subscription
      switch($ipn['payment_status']){
        case 'Completed':
          commerce_subscription_update_subscription_status($subscription_id, COMMERCE_SUBSCRIPTION_ACTIVE);
          break;
      }
      break;
  }
}

/**
 * Updates the status of a subscription and grants/removes roles as appropriate.
 * @param $subscription_id
 * @param $new_status
 */

function commerce_subscription_update_subscription_status($subscription_id, $new_status) {


  $subscription = commerce_subscription_load($subscription_id);
  $subscription_wrapper = entity_metadata_wrapper('commerce_subscription', $subscription);

  // We need to update various other things based on how the status changing:
  switch ($new_status) {
    case COMMERCE_SUBSCRIPTION_CREATED:
      // This is a new subscription.
      // Nothing really happens until it's active though.
      break;
    case COMMERCE_SUBSCRIPTION_ACTIVE:
      // Grant role.
      commerce_subscription_grant_role($subscription_wrapper->uid->value(), $subscription_wrapper->role->value());
      // Ensure the user is active.
      $account = user_load($subscription_wrapper->uid->value());
      if (is_object($account) && $account->status != 1) {
        user_save($account, array('status' => 1));
      }
      break;

    case COMMERCE_SUBSCRIPTION_FINISHED:
    case COMMERCE_SUBSCRIPTION_CANCELLED_USER:
    case COMMERCE_SUBSCRIPTION_CANCELLED_ADMIN:
    case COMMERCE_SUBSCRIPTION_FAILED:
      // Remove role.
      commerce_subscription_grant_role($subscription_wrapper->uid->value(), $subscription_wrapper->role->value(), FALSE);

      // This should probably log something for the failure cases.
      // @todo - Figure out what sort of log we want. Watchdog?
      break;
  }

  $subscription->status = $new_status;

  commerce_subscription_save($subscription);
}

/**
 * Implementation of hook_user_role_insert();
 */

function commerce_subscription_user_role_insert($role) {

  // React to the insertion of a new role and add it to the list of roles that
  // can be referenced by our subscription_role field:

  $field = field_read_field('subscription_role');
  $field['settings']['referenceable_roles'][$role->rid] = $role->name;
  field_update_field($field);
}

function commerce_subscription_units() {
  return array(
    COMMERCE_SUBSCRIPTION_DURATION_DAYS => 'Days',
    COMMERCE_SUBSCRIPTION_DURATION_WEEKS => 'Weeks',
    COMMERCE_SUBSCRIPTION_DURATION_MONTHS => 'Months',
    COMMERCE_SUBSCRIPTION_DURATION_YEARS => 'Years',
  );
}

/**
 * Nicely formats the length of a period of a subscription.
 * Eg, 2 years, 11 months, 1 month, etc.
 *
 * @param integer $period Number of the quantity
 * @param integer $units Units. See commerce_subscription_price_units() for mapping.
 * @param boolean $force_display_one Forces the period to display if it's one.
 *
 */

function commerce_subscription_length_format($period, $units, $force_display_one = FALSE) {

  $unit_words = array_map('strtolower', commerce_subscription_units());

  if ($period > 1) {
    $units_formatted = $unit_words[$units];
    return t("!number $units_formatted", array('!number' => $period));
  }
  else {
    // Chop the plural 's' off the units here:
    $units_formatted = substr($unit_words[$units], 0, -1);

    if ($force_display_one) {
      return t("!number $units_formatted", array('!number' => $period));
    }
    else {
      return t($units_formatted);
    }
  }
}

function commerce_subscription_get_price_short($product) {

  $price = $product->commerce_price[LANGUAGE_NONE][0];
  $recurs = $product->subscription_recurs[LANGUAGE_NONE][0]['value'];
  $recur_limit = $product->subscription_recur_limit[LANGUAGE_NONE][0]['value'];
  $units = $product->subscription_units[LANGUAGE_NONE][0]['value'];
  $period = $product->subscription_period[LANGUAGE_NONE][0]['value'];

  ob_start();

  if ($recurs > 0) {

    echo commerce_currency_format($price['amount'], $price['currency_code']);
    echo ' every ';
    echo commerce_subscription_length_format($period, $units);

    if ($recur_limit > 0) {
      echo ", for " . commerce_subscription_length_format($recur_limit, $units, TRUE);
    }
  }
  else {

    if ($price['amount'] == 0) {
      echo 'Free - no payment required';
    }
    else {
      echo 'a single payment of ' . commerce_currency_format($price['amount'], $price['currency_code']);
    }
  }

  // For some reason there's a rogue space on the end:
  return trim(ob_get_clean()) . '.';
}

function commerce_subscription_get_price_long($product) {

  $trial_period = $product->subscription_trial_period[LANGUAGE_NONE][0]['value'];
  $trial_units = $product->subscription_trial_units[LANGUAGE_NONE][0]['value'];
  $trial_price = $product->subscription_trial_price[LANGUAGE_NONE][0];

  $trial_2_period = $product->subscription_trial_period[LANGUAGE_NONE][1]['value'];
  $trial_2_units = $product->subscription_trial_units[LANGUAGE_NONE][1]['value'];
  $trial_2_price = $product->subscription_trial_2_price[LANGUAGE_NONE][0];

  ob_start();

  // If there's an initial trial period
  if ($trial_period > 0) {

    if ($trial_price['amount'] > 0) {
      echo commerce_currency_format($trial_price['amount'], $trial_price['currency_code']);
    }
    else {
      echo 'free';
    }

    echo ' for ' . commerce_subscription_length_format($trial_period, $trial_units, TRUE);

    // If there's a second trial period
    if ($trial_2_period > 0) {

      echo ', then ';

      if ($trial_2_price['amount'] > 0) {
        echo commerce_currency_format($trial_2_price['amount'], $trial_2_price['currency_code']);
      }
      else {
        echo 'free';
      }

      echo ' for ' . commerce_subscription_length_format($trial_2_period, $trial_2_units, TRUE);
    }

    echo ', followed by ';
  }

  echo commerce_subscription_get_price_short($product);

  return ucfirst(ob_get_clean());
}

/**
 * Implementation of hook_form_alter for commerce-paypal-wps-redirect-form
 * @param array $form
 * @param array $form_state
 */

function commerce_subscription_form_commerce_paypal_wps_redirect_form_alter(&$form, &$form_state) {

  $order = $form_state['build_info']['args'][0];
	$account = user_load($order->uid);
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Look at each line item in turn to determine if it's a subscription
  // product that wee need to take action on.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {

    if ($line_item_wrapper->type->value() == 'product') {

      $product_wrapper = $line_item_wrapper->commerce_product;

      if ($product_wrapper->type->value() == 'subscription') {

        $units = array(
          COMMERCE_SUBSCRIPTION_DURATION_DAYS => 'D',
          COMMERCE_SUBSCRIPTION_DURATION_WEEKS => 'W',
          COMMERCE_SUBSCRIPTION_DURATION_MONTHS => 'M',
          COMMERCE_SUBSCRIPTION_DURATION_YEARS => 'Y',
        );

        $product = commerce_product_load($product_wrapper->product_id->value());
        $subscription = commerce_subscription_create_subscription($product,$account->uid);

				$paypal_fields = array(
         'item_name' => variable_get('site_name'),
         'a3' => commerce_currency_amount_to_decimal($product_wrapper->commerce_price->amount->value(), $product_wrapper->commerce_price->currency_code->value()),
         'p3' => $product_wrapper->subscription_period->value() == 0 ? 1 : $product_wrapper->subscription_period->value(),
         't3' => $units[$product_wrapper->subscription_units->value()],
         'src' => $product_wrapper->subscription_recurs->value(),
         'srt' => ($product_wrapper->subscription_recurs->value() != 0 && $product_wrapper->subscription_recur_limit->value() > 0) ? (1 + $product_wrapper->subscription_recur_limit->value()) : 0,
         'sra' => true,
         'no_note' => true,
         'custom' => $subscription->subscription_id,
         'modify' => false,
        );
				
        if ($product_wrapper->subscription_recurs->value() != 0) {
          //change the default command and make it a subscription
          $paypal_fields['cmd'] = '_xclick-subscriptions';
        }

        if ($product_wrapper->subscription_trial_1_period->value() > 0) {
          $paypal_fields['a1'] = sprintf('%0.2f',$product_wrapper->subscription_trial_price->amount->value());
          $paypal_fields['p1'] = $product_wrapper->subscription_trial_1_period->value();
          $paypal_fields['t1'] = $units[$product_wrapper->subscription_trial_1_units->value()];
        }

        if ($product_wrapper->subscription_trial_2_period->value() > 0) {
          $paypal_fields['a2'] = sprintf('%0.2f',$product_wrapper->subscription_trial_2_price->amount->value());
          $paypal_fields['p2'] = $product_wrapper->subscription_trial_2_period->value();
          $paypal_fields['t2'] = $units[$product_wrapper->subscription_trial_2_units->value()];
        }

        foreach ($paypal_fields as $name => $value) {
          if (!empty($value)) {
            $form[$name] = array('#type' => 'hidden', '#value' => $value);
          }
        }
      }
    }
  }
}
